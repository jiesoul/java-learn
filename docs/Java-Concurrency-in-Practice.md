# Java Concurrency in Practice

## 线程安全

写线程安全的代码的核心是管理使用状态，尤其是共享、可变状态。

共享意味着变量能被多个线程处理，可变意味着在它的生命周期内可被改变。线程安全的真正上目的是保护数据无限制的并发处理。

关注对象怎么被使用而不是对象做什么。

当多于一个线程处理一个给定的变量时，线程中的一个可能会改变它，这些线程必须使用同步来协调处理。Java 中的主要机制是 synchronization 关键字，它提供一个独占锁。synchronization 也包括 volatile 变量，显式锁和原子变量。

程序忽略必须的同步可能看起来能工作，在几年内能通过测试，执行得很好，但是它一直都是损坏的，随时都可能失败。

有三个途径去修复程序：

* 不要在线程之间共享状态变量
* 使状态变量不可变
* 当处理状态变量时使用 synchronization 

为了线程安全设计类要比之后为了线程安全改良容易得多。

当设计线程安全的类时，好的面象对象的技术包括封闭性，不变性，不变性的明确规范是你最好的朋友。

当一个类被多个线程处理时它有正确的执行行为那么它就是线程安全的。

无状态的对象始终是线程安全的。

Operations A and B are atomic with respect to each other if, from the
perspective of a thread executing A, when another thread executes B,
either all of B has executed or none of it has. An atomic operation is one that is atomic with respect to all operations, including itself, that operate on the same state.

实际中，使用已经存在的线程安全对象，像 AtomicLong, 去管理你的类状态。现存的线程安全对象比随意的状态变量更能简单的推断可能的状态和状态转换，并且这对于保持和验证线程安全更简单。

为了保持状态一致，更新有关联状态变量在单一原子操作。

对于每一个多状态变量可能被一个或多个线程处理，所有的处理都是变量被相同的锁持有。这种情况，我们说变量是被锁保护的。

每一个共享的，多状态的变量应该被确切的一个锁保护。能清晰的维护它是哪一个锁。

## 共享对象

使用 volatile 当下面的情况时：

* 写入变量不依赖于它的当前值，或你能保证只有单一线程更新这个值。
* 该变量不加入其它状态变量的不变量。
* 当变量正被处理时，加锁不需要其它因素。

一个对象是不可变的：

* 它的状态不能被更改在构造这后
* 所有它的域是 final
* 它是适当的构造(在构造期 this 引用不能丢失)

最佳实践-使所有的域是 private 除非它需要更大的可见性，所有的域都是 final 除非它们需要可变性。

对于安全的公布一个对象，对象的引用和对象的状态必须同时可见。一个适当的构造对象能通过以下方法安全公布：

* 初始化对象引用使用静态初始化
* 使用 volatile 域 和 atomicReference 存储引用
* 用一个适当的构造对象的 final 域存储对象引用
* 通过锁对存储引用域适当的保护

## 组合对象

### 设计线程安全的类 

设计线程安全的过程应该包括三个 基本元素：

* 找出构造对象状态的所有变量;
* 找出约束状态变量的不变性条件。
* 建立对象状态的并发访问管理策略。

是所有域的子集的同步，关系到类是不是线程安全的。

不理解对象的不变性和后置条件，你不能确保线程安全。对状态变量限制有效值或者状态转换满足原子和封闭的需求。

### 实例封闭

对象不是线程安全的，可以通对象只能由单个线程访问(线程访问)，或者一个锁来保护该对象的所有访问。

将对象封闭在对象内部，可以将数据的访问限制在对象的方法上，从而更容易的确保线程在访问数据时总能持有正确的锁。

被封闭的对象一定不能超出它们的既定作用域。对象可以封闭在类的一个实例中，或者封闭在某个作用域内，再或者封闭在线程内。

## 构造块

## 任务执行






