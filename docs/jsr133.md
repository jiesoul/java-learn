# JSR-133

## 介绍

JVM 支持多个线程执行。线程用 Thread 类表示。用户创建线程的唯一途径是创建 Thread 类的对象；每个线程用
这样一个对象关联。使用 start() 方法启动。

线程的行为特别是不能正确同步时，会让人困惑和感觉不符常理。

### 锁

有多种机制可以在线程间传递。最基本的是同步(synchronization)，使用监视器(monitor)实现。每个对象分配
一个监视器，线程可以 lock 或 unlock 状态。在监视器上一次只能有一个线程可能持有一个锁(lock).任何其它
线程尝试加锁监视器会被阻塞直到它们能获得监视器上的锁。

一个线程 t 可能多次锁定一个特定的监视器，每次解锁都是一个锁定操作的反作用。

synchronization 声明计算一个指向对象的引用；然后尝试执行锁操作在对象的监视器上并且直到锁操作成功完成
前不能继续处理。在锁操作执行后，synchronization 声明的主体被执行。如果主体完成执行，或正常或意外，
相同的监视器上一个解锁的操作自动执行。

synchronized 方法在它调用时自动执行加锁操作; 直到锁操作成功完成前函数体不会执行。如果方法是实例方法，
它锁的监视器分配在被调用的实例(执行方法的对象 this)上。如果方法是静态的，它锁监视器在方法定义的类对象上。
如果主体完成执行，或正常或意外，相同的监视器上一个解锁的操作自动执行。

语义上即不预防也不需要观察死锁条件。线程在多个对象上持有(间接或直接)锁的程序应该使用常规的技术来规避死锁。，
如果必须，创建高级的不会死锁的原来锁。

其它代替方案： java.util.concurrent 包内的 volatile变量的读写和类。

## 不正确的 synchronization 程序展示意想不到的行为

## 正式语义

程序必须 correctly synchronized 能避免多种上不合理的行为，这些行为在程序被重排时会被观察到。正确同步的使用不能保证全部程序是正确的。
