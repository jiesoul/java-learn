# java8 实战

## 为什么要关心 Java 8

第一个编程概念是流处理。介绍一下，流是一系列数据项，一次只生成一项。程序可以从输入流中一个一个读取数据项，然后以同样的方式将数据项写入输出流。一个程序的输出流很可能是另一个程序的输入流。

这两个要点（没有共享的可变数据，将方法和函数即代码传递给其他方法的能力）是我们平常所说的函数式编程范式的基石。

在Java 8里写下File::isHidden 的时候，你就创建了一个方法引用，你同样可以传递它。

Java中从函数式编程中引入的两个核心思想：将方法和Lambda作为一等值，以及在没有可变共享状态时，函数或方法可以有效、安全地并行执行。

## 通过行为参数化传递代码

行为参数化就是可以帮助你处理频繁变更的需求的一种软件开发模式。一言以蔽之，它意味着拿出一个代码块，把它准备好却不去执行它。这个代码块以后可以被你程序的其他部分调用，这意味着你可以推迟这块代码的执行。

## Lambda 表达式

## 引入流

### 流简介

流到底是什么呢？简短的定义就是“从支持数据处理操作的源生成的元素序列”。定义剖析：

* 元素序列——就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如 ArrayList 与 LinkedList ）。但流的目的在于表达计算，比如你前面见到的 filter 、 sorted 和 map 。集合讲的是数据，流讲的是计算。我们会在后面几节中详细解释这个思想。
  
* 源——流会使用一个提供数据的源，如集合、数组或输入/输出资源。请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。
  
* 数据处理操作——流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如 filter 、 map 、 reduce 、 find 、 match 、 sort 等。流操作可以顺序执行，也可并行执行。

流操作两个重要特点：

* 流水线——很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大
  的流水线。这让我们下一章中的一些优化成为可能，如延迟和短路。流水线的操作可以
  看作对数据源进行数据库式查询

* 内部迭代——与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。

请注意，和迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。

### 流操作

两类操作：

* filter 、 map 和 limit 可以连成一条流水线；
* collect 触发流水线执行并关闭它。

可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作。

###  使用流

流的使用一般包括三件事：
* 一个数据源（如集合）来执行一个查询；
* 一个中间操作链，形成一条流的流水线；
* 一个终端操作，执行流水线，并能生成结果。

## 使用流

### 筛选和切片

Streams 接口支持 filter 方法（你现在应该很熟悉了）。该操作会接受一个谓词（一个返回
boolean 的函数）作为参数，并返回一个包括所有符合谓词的元素的流。

流还支持一个叫作 distinct 的方法，它会返回一个元素各异（根据流所生成元素的
hashCode 和 equals 方法实现）的流。

流支持 limit(n) 方法，该方法会返回一个不超过给定长度的流。所需的长度作为参数传递给 limit 。

流还支持 skip(n) 方法，返回一个扔掉了前 n 个元素的流。如果流中元素不足 n 个，则返回一个空流。请注意， limit(n) 和 skip(n) 是互补的！

### 映射

流支持 map 方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一个新版本”而不是去“修改”）。

flatmap 方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。

### 查找和匹配

anyMatch 方法可以回答“流中是否有一个元素能匹配给定的谓词”。anyMatch 方法返回一个 boolean ，因此是一个终端操作。

allMatch 方法的工作原理和 anyMatch 类似，但它会看看流中的元素是否都能匹配给定的谓词。

和 allMatch 相对的是 noneMatch 。它可以确保流中没有任何元素与给定的谓词匹配。

findAny 方法将返回当前流中的任意元素。它可以与其他流操作结合使用。

Optional<T> 类（ java.util.Optional ）是一个容器类，代表一个值存在或不存在。

有些流有一个出现顺序（encounter order）来指定流中项目出现的逻辑顺序（比如由 List 或排序好的数据列生成的流）。对于这种流，你可能想要找到第一个元素。为此有一个 findFirst方法，它的工作方式类似于 findany 。

### 归约

查询需要将流中所有元素反复结合起来，得到一个值，比如一个 Integer 。这样的查询可以被归类为归约操作（将流归约成一个值）。用函数式编程语言的术语来说，这称为折叠（fold），因为你可以将这个作看成把一张长长的纸（你的流）反复折叠成一个小方块，而这就是折叠操作的结果。

### 总结
* Streams API可以表达复杂的数据处理查询。常用的流操作总结在表5-1中。
* 你可以使用 filter 、 distinct 、 skip 和 limit 对流做筛选和切片。
* 你可以使用 map 和 flatMap 提取或转换流中的元素。
* 你可以使用 findFirst 和 findAny 方法查找流中的元素。你可以用 allMatch 、noneMatch 和 anyMatch 方法让流匹配给定的谓词。
* 这些方法都利用了短路：找到结果就立即停止计算；没有必要处理整个流。
* 你可以利用 reduce 方法将流中所有的元素迭代合并成一个结果，例如求和或查找最大元素。
* filter 和 map 等操作是无状态的，它们并不存储任何状态。 reduce 等操作要存储状态才能计算出一个值。 sorted 和 distinct 等操作也要存储状态，因为它们需要把流中的所有元素缓存起来才能返回一个新的流。这种操作称为有状态操作。
* 流有三种基本的原始类型特化： IntStream 、 DoubleStream 和 LongStream 。它们的操作也有相应的特化。
* 流不仅可以从集合创建，也可从值、数组、文件以及 iterate 与 generate 等特定方法创建。
* 无限流是没有固定大小的流

## 用流收集数据

### 归约和汇总



## 并行数据处理与性能

### 高效使用并行流

* 如果有疑问，测量。把顺序流转成并行流轻而易举，但却不一定是好事。我们在本节中已经指出，并行流并不总是比顺序流快。此外，并行流有时候会和你的直觉不一致，所以在考虑选择顺序流还是并行流时，第一个也是最重要的建议就是用适当的基准来检查其性能。
* 留意装箱。自动装箱和拆箱操作会大大降低性能。Java 8中有原始类型流（ IntStream 、LongStream 、 DoubleStream ）来避免这种操作，但凡有可能都应该用这些流。
* 有些操作本身在并行流上的性能就比顺序流差。特别是 limit 和 findFirst 等依赖于元素顺序的操作，它们在并行流上执行的代价非常大。例如， findAny 会比 findFirst 性能好，因为它不一定要按顺序来执行。你总是可以调用 unordered 方法来把有序流变成无序流。那么，如果你需要流中的n个元素而不是专门要前n个的话，对无序并行流调用limit 可能会比单个有序流（比如数据源是一个 List ）更高效。
* 还要考虑流的操作流水线的总计算成本。设N是要处理的元素的总数，Q是一个元素通过流水线的大致处理成本，则N*Q就是这个对成本的一个粗略的定性估计。Q值较高就意味着使用并行流时性能好的可能性比较大。
* 对于较小的数据量，选择并行流几乎从来都不是一个好的决定。并行处理少数几个元素的好处还抵不上并行化造成的额外开销。
* 要考虑流背后的数据结构是否易于分解。例如， ArrayList 的拆分效率比 LinkedList 高得多，因为前者用不着遍历就可以平均拆分，而后者则必须遍历。另外，用 range 工厂方法创建的原始类型流也可以快速分解。最后，你将在7.3节中学到，你可以自己实现 Spliterator 来完全掌控分解过程。
* 流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能。例如，一个 SIZED 流可以分成大小相等的两部分，这样每个部分都可以比较高效地并行处理，但筛选操作可能丢弃的元素个数却无法预测，导致流本身的大小未知。
* 还要考虑终端操作中合并步骤的代价是大是小（例如 Collector 中的 combiner 方法）。如果这一步代价很大，那么组合每个子流产生的部分结果所付出的代价就可能会超出通过并行流得到的性能提升。

### 分支/合并框架

* 对一个任务调用 join 方法会阻塞调用方，直到该任务做出结果。因此，有必要在两个子任务的计算都开始之后再调用它。否则，你得到的版本会比原始的顺序算法更慢更复杂，因为每个子任务都必须等待另一个子任务完成才能启动。
* 不应该在 RecursiveTask 内部使用 ForkJoinPool 的 invoke 方法。相反，你应该始终直接调用 compute 或 fork 方法，只有顺序代码才应该用 invoke 来启动并行计算。
* 对子任务调用 fork 方法可以把它排进 ForkJoinPool 。同时对左边和右边的子任务调用
它似乎很自然，但这样做的效率要比直接对其中一个调用 compute 低。这样做你可以为其中一个子任务重用同一线程，从而避免在线程池中多分配一个任务造成的开销。
* 调试使用分支/合并框架的并行计算可能有点棘手。特别是你平常都在你喜欢的IDE里面看栈跟踪（stack trace）来找问题，但放在分支合并计算上就不行了，因为调用 compute
的线程并不是概念上的调用方，后者是调用 fork 的那个。
* 和并行流一样，你不应理所当然地认为在多核处理器上使用分支/合并框架就比顺序计算快。我们已经说过，一个任务可以分解成多个独立的子任务，才能让性能在并行化时有所提升。所有这些子任务的运行时间都应该比分出新任务所花的时间长；一个惯用方法是把输入/输出放在一个子任务里，计算放在另一个里，这样计算就可以和输入/输出同时进行。此外，在比较同一算法的顺序和并行版本的性能时还有别的因素要考虑。就像任何其他Java代码一样，分支/合并框架需要“预热”或者说要执行几遍才会被JIT编译器优化。这就是为什么在测量性能之前跑几遍程序很重要，我们的测试框架就是这么做的。同时还要知道，编译器内置的优化可能会为顺序版本带来一些优势（例如执行死码分析——删去从未被使用的计算）。

## 重构、测试和调试

## 默认方法

## 用 Optional 取代 null

## CompletableFuture ：组合式异步编程

## 新的日期和时间 API

## 函数式的思考

## 函数式编程的技巧

## 面向对象和函数式编程的混合：Java 8 和 Scala 的比较 

## 结论以及 Java 的未来